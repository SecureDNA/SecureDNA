// Copyright 2021-2024 SecureDNA Stiftung (SecureDNA Foundation) <licensing@securedna.org>
// SPDX-License-Identifier: MIT OR Apache-2.0

use std::sync::Arc;

use wasm_bindgen::prelude::*;
use wasm_bindgen_test::*;

use doprf_client::{
    retry_if,
    server_selection::{
        ServerEnumerationSource, ServerSelectionConfig, ServerSelectionError, ServerSelector,
    },
};
use http_client::{BaseApiClient, HttpsToHttpRewriter};
use quickdna::{DnaSequence, FastaFile, NucleotideAmbiguous};
use scep_client_helpers::ClientCerts;
use serde::{Deserialize, Serialize};
use shared_types::{requests::RequestId, server_selection::Tier};
use synthclient::{
    api::Region,
    parsefasta::{
        check_fasta, check_parsed_fasta, CheckerConfiguration, CurrentSystemLoadTracker,
        LimitConfiguration,
    },
};

const MAX_REQUEST_BP: usize = 1_000_000;

// #[cfg(target_arch = "wasm32")]
// pub use wasm_bindgen_rayon::init_thread_pool;

extern crate console_error_panic_hook;

wasm_bindgen_test_configure!(run_in_browser);

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct ScreenConfig {
    region: Region,
    enumeration_settings: Option<EnumerationSettings>,
    fixed_domains: Option<FixedDomains>,
    include_debug_info: bool,
    request_id: String,
    use_http: bool,
    token_contents: Vec<u8>,
    keypair_contents: Vec<u8>,
    keypair_passphrase: String,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct EnumerationSettings {
    tier: Tier,
    apex: String,
    doh_provider: String,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct FixedDomains {
    keyserver_domains: Vec<String>,
    hdb_domains: Vec<String>,
}

/// A custom bit of TypeScript code that integrates tsgen with wasm-bindgen.
///
/// The "all_bindings" referred to in this section is generated by
/// `wasm_bindings/build.rs`, which invokes tsgen, which puts the bindings in
/// `wasm_bindings/*/pkg` where this snippet can see them.
#[wasm_bindgen(typescript_custom_section)]
const IMPORTS: &'static str = r#"
// Import/export bindings generated by `wasm_bindings/build.rs`:
import { ApiResponse, ScreenConfig } from "./all_bindings";
export * from "./all_bindings";
"#;

// The block of code below lets us generate .d.ts files with proper TypeScript
// types. The types referred to are imported by `IMPORTS` above.
///
/// See wasm_bindings/certificates/src/lib.rs for an explanation.
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(typescript_type = "ApiResponse")]
    pub type IApiResponse;
    #[wasm_bindgen(typescript_type = "ScreenConfig")]
    pub type IScreenConfig;
}

#[wasm_bindgen]
pub async fn screen(sequence: JsValue, config: IScreenConfig) -> Result<IApiResponse, String> {
    console_error_panic_hook::set_once();

    let ScreenConfig {
        region,
        enumeration_settings,
        fixed_domains,
        include_debug_info,
        request_id,
        use_http,
        token_contents,
        keypair_contents,
        keypair_passphrase,
    } = serde_wasm_bindgen::from_value(config.into())
        .map_err(|e| format!("Couldn't decode JSON: {e:?}"))?;

    let request_id = RequestId(request_id);
    let limits = CurrentSystemLoadTracker::default();

    let enumeration_source = match (enumeration_settings, fixed_domains) {
        (Some(enumeration_settings), None) => ServerEnumerationSource::DnsOverHttps {
            provider_domain: enumeration_settings.doh_provider,
            tier: enumeration_settings.tier,
            apex: enumeration_settings.apex,
        },
        (None, Some(fixed_domains)) => {
            if fixed_domains.keyserver_domains.is_empty() || fixed_domains.hdb_domains.is_empty() {
                return Err("`fixed_domains.keyserver_domains` and `fixed_domains.hdb_domains` must both be non-empty!".into());
            } else {
                ServerEnumerationSource::Fixed {
                    keyserver_domains: fixed_domains.keyserver_domains,
                    hdb_domains: fixed_domains.hdb_domains,
                }
            }
        }
        (None, None) | (Some(_), Some(_)) => {
            return Err(
                "Must provide exactly one of `fixed_domains` and `enumeration_settings`!".into(),
            )
        }
    };

    let api_client = {
        let client = BaseApiClient::new(RequestId::new_unique_with_prefix("server-selection"));
        if use_http {
            HttpsToHttpRewriter::inject(client)
        } else {
            client
        }
    };
    // TODO: it's really slow to do this every time, we should cache it between requests somewhow
    let server_selector = retry_if::retry_if(
        || {
            async {
                let selector = ServerSelector::new(
                    ServerSelectionConfig {
                        enumeration_source: enumeration_source.clone(),
                        // TODO: since for now we're making the server selector fresh every
                        // time, these fields don't matter
                        soft_timeout: None,
                        blocking_timeout: None,
                        soft_extra_keyserver_threshold: None,
                        soft_extra_hdb_threshold: None,
                    },
                    api_client.clone(),
                )
                .await?;
                Ok::<Arc<ServerSelector>, ServerSelectionError>(Arc::new(selector))
            }
        },
        |_| true,
    )
    .await
    .map_err(|e| format!("Server selection failed: {e}"))?;

    #[cfg(not(test))]
    let certs = ClientCerts::load_from_contents_with_prod_roots(
        token_contents,
        keypair_contents,
        &keypair_passphrase,
    );
    #[cfg(test)]
    let certs = ClientCerts::load_from_contents_with_test_roots(
        token_contents,
        keypair_contents,
        &keypair_passphrase,
    );
    let certs = certs.map_err(|e| format!("Couldn't load certs: {e}"))?;
    let version = securedna_versioning::version::get_version();

    let config = CheckerConfiguration {
        server_selector,
        include_debug_info,
        limit_config: LimitConfiguration {
            memory_limit: None,
            max_request_bp: MAX_REQUEST_BP,
            limits: &limits,
        },
        metrics: None,
        region,
        use_http,
        certs: Arc::new(certs),
        provider_reference: Some(format!("wasm_bindings {request_id}")),
        synthclient_version_hint: &format!("wasm_bindings {version}"),
        elt: None, // TODO: support using ELT for wasm screening?
        otp: None,
        server_version_handler: Default::default(), // don't check server versions in wasm
    };

    let result = match sequence.as_string() {
        Some(unparsed) => check_fasta::<NucleotideAmbiguous>(&request_id, unparsed, &config).await,
        None => {
            let fasta_file: FastaFile<DnaSequence<NucleotideAmbiguous>> =
                serde_wasm_bindgen::from_value(sequence).unwrap();
            check_parsed_fasta::<NucleotideAmbiguous>(&request_id, fasta_file, &config).await
        }
    };

    let response = result.map_err(|e| format!("screening error: {e:?}"))?;

    match serde_wasm_bindgen::to_value(&response) {
        Ok(r) => Ok(r.into()),
        Err(e) => Err(format!("error converting response: {e:?}")),
    }
}

#[cfg(target_arch = "wasm32")]
#[wasm_bindgen_test]
async fn screen_influenza() {
    use scep_client_helpers::ClientCerts;
    use synthclient::api::{ApiResponse, SynthesisPermission};

    // This is an arbitrary known sequence in our testhdb
    let sequence = JsValue::from_str(
        r#">Virus
CTTCGCGGGATGAGTGTTTTGCCATCTAATAAGTCCAACATTAATTACGGTGCATCAGGC"#,
    );

    let certs = ClientCerts::load_test_certs();
    let passphrase = "test";
    let mut keypair_contents: Vec<u8> = Vec::new();
    certs
        .keypair
        .write_key(&mut keypair_contents, passphrase)
        .unwrap();
    let token_contents = certs.token.to_file_contents().unwrap().into();

    let config = ScreenConfig {
        region: Region::All,
        enumeration_settings: None,
        fixed_domains: Some(FixedDomains {
            keyserver_domains: vec![
                std::env::var("KEYSERVER1_URL")
                    .unwrap_or("ks1.localhost.securedna.org:5301".to_string()),
                std::env::var("KEYSERVER2_URL")
                    .unwrap_or("ks2.localhost.securedna.org:5302".to_string()),
                std::env::var("KEYSERVER3_URL")
                    .unwrap_or("ks3.localhost.securedna.org:5303".to_string()),
            ],
            hdb_domains: vec![std::env::var("HDBSERVER_URL")
                .unwrap_or("db1.localhost.securedna.org:5300".to_string())],
        }),
        include_debug_info: true,
        request_id: "screening_wasm_test".to_string(),
        use_http: true,
        keypair_contents,
        token_contents,
        keypair_passphrase: passphrase.to_owned(),
    };

    let config: IScreenConfig = serde_wasm_bindgen::to_value(&config).unwrap().into();
    let outcome = screen(sequence, config).await.unwrap();
    let response: ApiResponse = serde_wasm_bindgen::from_value(outcome.into()).unwrap();

    assert_eq!(response.synthesis_permission, SynthesisPermission::Denied);
    assert_ne!(response.hits_by_record.len(), 0);
    assert_ne!(response.hits_by_record[0].hits_by_hazard.len(), 0);
    assert!(response.hits_by_record[0].hits_by_hazard[0]
        .most_likely_organism
        .ans
        .contains(&"AN1000000.1".into()));
}
