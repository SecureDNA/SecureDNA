// Copyright 2021-2024 SecureDNA Stiftung (SecureDNA Foundation) <licensing@securedna.org>
// SPDX-License-Identifier: MIT OR Apache-2.0

use certificates::{
    Authenticator, CertificateBundle, Description, ExemptionListTokenGroup,
    ExemptionListTokenRequest, Expiration, KeyPair, Organism, PemDecodable, PemEncodable,
    TokenBundle,
};
use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;

extern crate console_error_panic_hook;

/// A custom bit of TypeScript code that integrates tsgen with wasm-bindgen.
///
/// The "all_bindings" referred to in this section is generated by
/// `wasm_bindings/build.rs`, which invokes tsgen and moves the bindings into
/// `wasm_bindings/*/pkg` where this snippet can see them.
#[wasm_bindgen(typescript_custom_section)]
const IMPORTS: &'static str = r#"
// Import/export bindings generated by `wasm_bindings/build.rs`:
import { EltrV1Fields, ExemptionListToken, ExemptionListTokenRequest, SignEltr } from "./all_bindings";
export * from "./all_bindings";
"#;

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct EltrV1Fields {
    exemptions: Vec<Organism>,
    requestor: Description,
    requestor_auth_devices: Vec<Authenticator>,
    shipping_addresses: Vec<Vec<String>>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct SignEltr {
    eltr_pem: Vec<u8>,
    cert_pem: Vec<u8>,
    private_key_pem: Vec<u8>,
    passphrase: Vec<u8>,
    validity_days: i64,
}

// The block of code below lets us generate .d.ts files with proper TypeScript
// types. The types referred to are imported by `IMPORTS` above.
//
// We can't just e.g. use the Rust type `SignEltr` directly in the signatures in
// this file, as this generates a binding that expects an *instance* of some
// class `SignEltr`, whereas `SignEltr` is a plain JavaScript object.
//
// What the code below achieves is that `ISignEltr` is translated to `SignEltr`
// in the TypeScript bindings, but on the Rust side it's a "dummy" type that
// impls `Into<JsValue>`, on which we can use `serde_wasm_bindgen::from_value`.
//
// See also:
// * https://rustwasm.github.io/docs/wasm-bindgen/reference/attributes/on-rust-exports/typescript_type.html
// * https://github.com/rustwasm/wasm-bindgen/issues/2645
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(typescript_type = "EltrV1Fields")]
    pub type IEltrV1Fields;
    #[wasm_bindgen(typescript_type = "ExemptionListToken")]
    pub type IExemptionListToken;
    #[wasm_bindgen(typescript_type = "ExemptionListTokenRequest")]
    pub type IExemptionListTokenRequest;
    #[wasm_bindgen(typescript_type = "SignEltr")]
    pub type ISignEltr;
}

#[wasm_bindgen]
pub fn make_eltr_v1_pem(fields: IEltrV1Fields) -> Result<Vec<u8>, String> {
    console_error_panic_hook::set_once();
    let fields: EltrV1Fields = serde_wasm_bindgen::from_value(fields.into())
        .map_err(|e| format!("Couldn't decode JSON: {e:?}"))?;
    let eltr = ExemptionListTokenRequest::v1_token_request(
        fields.exemptions,
        fields.requestor,
        fields.requestor_auth_devices,
        fields.shipping_addresses,
    );
    match eltr.to_pem() {
        Ok(pem) => Ok(pem.into_bytes()),
        Err(e) => Err(format!("Couldn't encode PEM: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn eltr_pem_to_js_object(eltr_pem: Vec<u8>) -> Result<IExemptionListTokenRequest, String> {
    let eltr = ExemptionListTokenRequest::from_pem(eltr_pem)
        .map_err(|e| format!("Couldn't decode ELTR: {e:?}"))?;

    match serde_wasm_bindgen::to_value(&eltr) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!("Couldn't convert ELTR to JS: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn elt_bundle_pem_to_js_object(elt_pem: Vec<u8>) -> Result<IExemptionListToken, String> {
    let elt_bundle = TokenBundle::<ExemptionListTokenGroup>::from_file_contents(elt_pem)
        .map_err(|e| format!("Couldn't decode ELT: {e:?}"))?;

    match serde_wasm_bindgen::to_value(&elt_bundle.token) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!("Couldn't convert ELT to JS: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn sign_eltr(body: ISignEltr) -> Result<Vec<u8>, String> {
    let SignEltr {
        eltr_pem,
        cert_pem,
        private_key_pem,
        passphrase,
        validity_days,
    } = serde_wasm_bindgen::from_value(body.into())
        .map_err(|e| format!("Couldn't decode JSON: {e:?}"))?;

    let eltr = ExemptionListTokenRequest::from_pem(eltr_pem)
        .map_err(|e| format!("Couldn't decode ELTR: {e:?}"))?;

    let keypair = KeyPair::load_key(private_key_pem, passphrase)
        .map_err(|_| "Couldn't decrypt key".to_string())?;

    let cert_bundle = CertificateBundle::from_file_contents(cert_pem)
        .map_err(|e| format!("Couldn't decode cert bundle: {e:?}"))?;

    let cert = cert_bundle
        .get_lead_cert()
        .map_err(|e| format!("Couldn't retrieve certificate from file: {e:?}"))?
        .to_owned()
        .load_key(keypair)
        .map_err(|e| format!("Invalid private key: {e:?}"))?;

    let expiration = Expiration::expiring_in_days(validity_days)
        .map_err(|e| format!("Invalid expiration: {e:?}"))?;

    let issuer_auth_devices: Vec<Authenticator> = vec![];

    let elt = cert
        .issue_elt(eltr, expiration, issuer_auth_devices)
        .map_err(|e| format!("Couldn't issue ELT: {e:?}"))?;

    let chain = cert_bundle.issue_chain();
    let elt_bundle = TokenBundle::<ExemptionListTokenGroup>::new(elt, chain);

    let elt_pem = elt_bundle
        .to_file_contents()
        .map_err(|e| format!("Couldn't encode ELT: {e:?}"))?;

    Ok(elt_pem.into_bytes())
}
