// Copyright 2021-2024 SecureDNA Stiftung (SecureDNA Foundation) <licensing@securedna.org>
// SPDX-License-Identifier: MIT OR Apache-2.0

use certificates::{
    AuditRecipient, Authenticator, Builder, CertificateBundle, Description, Digestible,
    ExemptionTokenGroup, ExemptionTokenRequest, Expiration, KeyPair, Manufacturer, Organism,
    PemDecodable, PemEncodable, PublicKey, RequestBuilder, SynthesizerTokenRequest, TokenBundle,
};
use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;

/// A custom bit of TypeScript code that integrates tsgen with wasm-bindgen.
///
/// The "all_bindings" referred to in this section is generated by
/// `wasm_bindings/build.rs`, which invokes tsgen and moves the bindings into
/// `wasm_bindings/*/pkg` where this snippet can see them.
#[wasm_bindgen(typescript_custom_section)]
const IMPORTS: &'static str = r#"
// Import/export bindings generated by `wasm_bindings/build.rs`:
import { EtrV1Fields, ExemptionToken, ExemptionTokenRequest, SignEtr } from "./all_bindings";
export * from "./all_bindings";
"#;

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct EtrV1Fields {
    public_key_pem: Option<String>,
    exemptions: Vec<Organism>,
    requestor: Description,
    requestor_auth_devices: Vec<Authenticator>,
    shipping_addresses: Vec<Vec<String>>,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct SignEtr {
    etr_pem: Vec<u8>,
    cert_pem: Vec<u8>,
    private_key_pem: Vec<u8>,
    passphrase: Vec<u8>,
    validity_days: i64,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct CertRequestFiles {
    certr_pem: String,
    private_key_pem: String,
    public_key_pem: String,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct CreateSynthesizerToken {
    domain: String,
    model: String,
    serial: String,
    rate_limit: u64,
    audit_email: Option<String>,
    audit_public_key: Option<String>,
    token_passphrase: String,
    cert_pem: String,
    cert_private_key_pem: String,
    cert_passphrase: String,
    days_valid: i64,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct SynthesizerTokenFiles {
    private_key_pem: String,
    synthesizer_token_pem: String,
}

#[derive(Debug, Clone, Deserialize, Serialize)]
#[wasm_bindgen(skip_typescript)]
// tsgen
pub struct PemKeyPair {
    private_key_pem: String,
    public_key_hexpem: String,
}

// The block of code below lets us generate .d.ts files with proper TypeScript
// types. The types referred to are imported by `IMPORTS` above.
//
// We can't just e.g. use the Rust type `SignEtr` directly in the signatures in
// this file, as this generates a binding that expects an *instance* of some
// class `SignEtr`, whereas `SignEtr` is a plain JavaScript object.
//
// What the code below achieves is that `ISignEtr` is translated to `SignEtr`
// in the TypeScript bindings, but on the Rust side it's a "dummy" type that
// impls `Into<JsValue>`, on which we can use `serde_wasm_bindgen::from_value`.
//
// See also:
// * https://rustwasm.github.io/docs/wasm-bindgen/reference/attributes/on-rust-exports/typescript_type.html
// * https://github.com/rustwasm/wasm-bindgen/issues/2645
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(typescript_type = "EtrV1Fields")]
    pub type IEtrV1Fields;
    #[wasm_bindgen(typescript_type = "ExemptionToken")]
    pub type IExemptionToken;
    #[wasm_bindgen(typescript_type = "ExemptionTokenRequest")]
    pub type IExemptionTokenRequest;
    #[wasm_bindgen(typescript_type = "SignEtr")]
    pub type ISignEtr;
    #[wasm_bindgen(typescript_type = "CertRequestFiles")]
    pub type ICertRequestFiles;
    #[wasm_bindgen(typescript_type = "CreateSynthesizerToken")]
    pub type ICreateSynthesizerToken;
    #[wasm_bindgen(typescript_type = "SynthesizerTokenFiles")]
    pub type ISynthesizerTokenFiles;
    #[wasm_bindgen(typescript_type = "PemKeyPair")]
    pub type IPemKeyPair;
}

#[wasm_bindgen(start)]
pub fn start() {
    console_error_panic_hook::set_once();
    tracing_wasm::set_as_global_default();
}

#[wasm_bindgen]
pub fn make_etr_v1_pem(fields: IEtrV1Fields) -> Result<Vec<u8>, String> {
    let fields: EtrV1Fields = serde_wasm_bindgen::from_value(fields.into())
        .map_err(|e| format!("Couldn't decode JSON: {e:?}"))?;

    let mut requestor = fields.requestor;
    if requestor.phone_number.as_deref() == Some("") {
        requestor.phone_number = None;
    }
    if requestor.orcid.as_deref() == Some("") {
        requestor.orcid = None;
    }
    if requestor.name.as_deref() == Some("") {
        requestor.name = None;
    }
    let public_key: Option<PublicKey> = match fields.public_key_pem {
        Some(pem) => {
            Some(PublicKey::from_pem(pem).map_err(|_| "Couldn't decode public key".to_owned())?)
        }
        None => None,
    };

    let etr = ExemptionTokenRequest::v1_token_request(
        public_key,
        fields.exemptions,
        requestor,
        fields.requestor_auth_devices,
        fields.shipping_addresses,
    );
    match etr.to_pem() {
        Ok(pem) => Ok(pem.into_bytes()),
        Err(e) => Err(format!("Couldn't encode PEM: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn etr_pem_to_js_object(etr_pem: Vec<u8>) -> Result<IExemptionTokenRequest, String> {
    let etr = ExemptionTokenRequest::from_pem(etr_pem)
        .map_err(|e| format!("Couldn't decode exemption token request: {e:?}"))?;

    match serde_wasm_bindgen::to_value(&etr) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!(
            "Couldn't convert exemption token request to JS: {e:?}"
        )),
    }
}

#[wasm_bindgen]
pub fn et_bundle_pem_to_js_object(et_pem: Vec<u8>) -> Result<IExemptionToken, String> {
    let et_bundle = TokenBundle::<ExemptionTokenGroup>::from_file_contents(et_pem)
        .map_err(|e| format!("Couldn't decode exemption token: {e:?}"))?;

    match serde_wasm_bindgen::to_value(&et_bundle.token) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!("Couldn't convert exemption token to JS: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn sign_etr(body: ISignEtr) -> Result<Vec<u8>, String> {
    let SignEtr {
        etr_pem,
        cert_pem,
        private_key_pem,
        passphrase,
        validity_days,
    } = serde_wasm_bindgen::from_value(body.into())
        .map_err(|e| format!("Couldn't decode JSON: {e:?}"))?;

    let etr = ExemptionTokenRequest::from_pem(etr_pem)
        .map_err(|e| format!("Couldn't decode exemption token request: {e:?}"))?;

    let keypair = KeyPair::load_key(private_key_pem, passphrase)
        .map_err(|_| "Couldn't decrypt key".to_string())?;
    let cert_bundle = CertificateBundle::from_file_contents(cert_pem)
        .map_err(|e| format!("Couldn't decode cert bundle: {e:?}"))?;

    let expiration = Expiration::expiring_in_days(validity_days)
        .map_err(|e| format!("Invalid expiration: {e:?}"))?;
    let et_bundle = cert_bundle
        .issue_exemption_token_bundle(etr, expiration, vec![], keypair)
        .map_err(|e| format!("Couldn't issue exemption token: {e:?}"))?;

    let et_pem = et_bundle
        .to_file_contents()
        .map_err(|e| format!("Couldn't encode exemption token: {e:?}"))?;

    Ok(et_pem.into_bytes())
}

#[wasm_bindgen]
pub fn create_manufacturer_leaf(
    name: String,
    email: String,
    passphrase: String,
) -> Result<ICertRequestFiles, String> {
    let keypair = KeyPair::new_random();
    let public_key = keypair.public_key();
    let mut private_key: Vec<u8> = vec![];
    keypair
        .write_key(&mut private_key, passphrase)
        .map_err(|_| "Couldn't write key".to_owned())?;

    let desc = Description::default().with_name(name).with_email(email);
    let builder =
        RequestBuilder::<Manufacturer>::leaf_v1_builder(public_key).with_description(desc);

    let files = CertRequestFiles {
        certr_pem: builder
            .build()
            .to_pem()
            .map_err(|_| "Couldn't make certr pem".to_owned())?,
        private_key_pem: String::from_utf8(private_key)
            .map_err(|_| "Invalid UTF-8 in priv pem".to_owned())?,
        public_key_pem: public_key
            .to_file_contents()
            .map_err(|_| "Couldn't make pub pem".to_owned())?,
    };

    match serde_wasm_bindgen::to_value(&files) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!("Couldn't convert files to JS: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn check_manufacturer_cert(
    cert_pem: String,
    cert_private_key_pem: String,
    cert_passphrase: String,
) -> Result<String, String> {
    let keypair = KeyPair::load_key(cert_private_key_pem, cert_passphrase)
        .map_err(|_| "Couldn't decrypt key".to_string())?;

    let cert_bundle = CertificateBundle::<Manufacturer>::from_file_contents(cert_pem)
        .map_err(|e| format!("Couldn't decode cert bundle: {e:?}"))?;

    let cert = cert_bundle
        .get_lead_cert()
        .map_err(|e| format!("Couldn't load certificate: {e}"))?
        .to_owned()
        .load_key(keypair.clone())
        .map_err(|e| format!("Invalid private key: {e:?}"))?;

    let digest = cert.into_digest();
    Ok(format!(
        "Issued by {} to {}",
        digest.issued_by.desc, digest.issued_to.desc
    ))
}

#[wasm_bindgen]
pub fn create_synthesizer_token(
    body: ICreateSynthesizerToken,
) -> Result<ISynthesizerTokenFiles, String> {
    let CreateSynthesizerToken {
        domain,
        model,
        serial,
        rate_limit,
        audit_email,
        audit_public_key,
        token_passphrase,
        cert_pem,
        cert_private_key_pem,
        cert_passphrase,
        days_valid,
    } = serde_wasm_bindgen::from_value(body.into())
        .map_err(|e| format!("Couldn't decode JSON: {e:?}"))?;

    let keypair = KeyPair::load_key(cert_private_key_pem, cert_passphrase)
        .map_err(|_| "Couldn't decrypt key".to_string())?;
    let cert_bundle = CertificateBundle::from_file_contents(cert_pem)
        .map_err(|e| format!("Couldn't decode cert bundle: {e:?}"))?;

    let audit_recipient = match (audit_email, audit_public_key) {
        (None, None) => Ok(None),
        (Some(email), Some(public_key)) => AuditRecipient::new(email, public_key)
            .map(Some)
            .map_err(|_| "Audit key parse error".to_owned()),
        (None, Some(_)) => Err("Missing audit email".to_owned()),
        (Some(_), None) => Err("Missing audit public key".to_owned()),
    }?;

    let token_keypair = KeyPair::new_random();
    let token_public_key = token_keypair.public_key();
    let mut token_private_key: Vec<u8> = vec![];
    token_keypair
        .write_key(&mut token_private_key, token_passphrase)
        .map_err(|_| "Couldn't write key".to_owned())?;

    let token_request = SynthesizerTokenRequest::v1_token_request(
        token_public_key,
        domain,
        model,
        serial,
        rate_limit,
        audit_recipient,
    );

    let expiration = Expiration::expiring_in_days(days_valid)
        .map_err(|e| format!("Invalid expiration: {e:?}"))?;

    let token_bundle = cert_bundle
        .issue_synthesizer_token_bundle(token_request, expiration, keypair)
        .map_err(|_| "Failed to issue token bundle".to_owned())?;

    let files = SynthesizerTokenFiles {
        private_key_pem: String::from_utf8(token_private_key)
            .map_err(|_| "Invalid UTF-8 in priv pem".to_owned())?,
        synthesizer_token_pem: token_bundle
            .to_file_contents()
            .map_err(|_| "Couldn't make synth token pem".to_owned())?,
    };

    match serde_wasm_bindgen::to_value(&files) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!("Couldn't convert files to JS: {e:?}")),
    }
}

#[wasm_bindgen]
pub fn subset_et(
    et_pem: Vec<u8>,
    etr_pem: Vec<u8>,
    private_key_pem: Vec<u8>,
    passphrase: Vec<u8>,
    validity_days: u32,
) -> Result<Vec<u8>, String> {
    let et_bundle = TokenBundle::<ExemptionTokenGroup>::from_file_contents(et_pem)
        .map_err(|e| format!("Couldn't decode exemption token: {e:?}"))?;

    let etr = ExemptionTokenRequest::from_pem(etr_pem)
        .map_err(|e| format!("Couldn't decode exemption token request: {e:?}"))?;

    let keypair = KeyPair::load_key(private_key_pem, passphrase)
        .map_err(|_| "Couldn't decrypt key".to_string())?;

    let expiration = Expiration::expiring_in_days(validity_days as i64)
        .map_err(|e| format!("Invalid expiration: {e:?}"))?;

    let sub_et = et_bundle
        .issue_exemption_token_bundle(
            etr,
            expiration,
            et_bundle.token.issuer_auth_devices().to_vec(),
            keypair,
        )
        .map_err(|e| format!("Failed to issue subset exemption token: {e:?}"))?;

    let sub_et_pem = sub_et
        .to_file_contents()
        .map_err(|e| format!("Couldn't encode exemption token: {e:?}"))?;

    Ok(sub_et_pem.into_bytes())
}

#[wasm_bindgen]
pub fn make_keypair(passphrase: String) -> Result<IPemKeyPair, String> {
    let keypair = KeyPair::new_random();
    let public_key_hexpem = keypair
        .public_key()
        .to_file_contents()
        .map_err(|_| "Couldn't make public key PEM".to_owned())?;

    let mut private_key_pem: Vec<u8> = vec![];
    keypair
        .write_key(&mut private_key_pem, passphrase)
        .map_err(|_| "Couldn't encrypt private key".to_owned())?;
    let private_key_pem = String::from_utf8(private_key_pem)
        .map_err(|_| "Invalid UTF-8 in private key".to_owned())?;

    let keypair = PemKeyPair {
        public_key_hexpem,
        private_key_pem,
    };

    match serde_wasm_bindgen::to_value(&keypair) {
        Ok(v) => Ok(v.into()),
        Err(e) => Err(format!("Couldn't convert keypair to JS: {e:?}")),
    }
}
